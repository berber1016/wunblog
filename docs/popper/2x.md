## å‰è¨€

ä½œä¸ºå‰ç«¯ï¼Œ`popper.js`æ˜¯ç»•ä¸è¿‡å»çš„ä¸€é“åï¼Œå®ƒä½œä¸ºåº•å±‚ç»„ä»¶ï¼Œå¸®åŠ©æˆ‘ä»¬è§£å†³äº† `Tooltip`ã€`dropdown`ã€`Menu`ç­‰ç­‰ä¸€ç³»åˆ—ç»„ä»¶ã€‚å‡ ä¹æ‰€æœ‰çš„è¿™æ ·çš„ç»„ä»¶éƒ½æ˜¯åŸºäº`Popper.js`ç»„ä»¶æ¥æ„æˆçš„ã€‚å®ƒçš„æ ¸å¿ƒåªæœ‰6000 byteå·¦å³ï¼Œå¹¶ä¸”æ”¯æŒ`tree-shaking`ï¼Œæ”¯æŒè‡ªå®šä¹‰ä¸­é—´ä»¶ã€æ”¯æŒä»»æ„æ¡†æ¶(åŸºäº `JavaScript`)ã€‚

> å½“å‰æ˜¯åŸºäºv2.xåˆ†æ”¯ä½œä¸ºåˆ†æï¼Œä»…é’ˆå¯¹2.xåˆ†æ”¯åˆ†æã€‚æœ€æ–°ç‰ˆæœ¬çš„popper.jså·²ç»æ›´åä¸ºfloating-uiã€‚

## åŸºæœ¬é€»è¾‘

```js
const defaultModifiers = [
  eventListeners,
  popperOffsets,
  computeStyles,
  applyStyles,
  offset,
  flip,
  preventOverflow,
  arrow,
  hide,
];
const createPopper = popperGenerator({ defaultModifiers });
```

popper.js åˆ©ç”¨ `popperGenerator`æ¥ç”Ÿæˆ `createPopper` å‡½æ•°ï¼Œå…¶ä¸­åˆå§‹åŒ–äº†ä¸€äº›ä¸­é—´ä»¶ã€‚

```js
const DEFAULT_OPTIONS = {
    placement: 'bottom',
    modifiers: [],
    strategy: 'absolute',
}
function popperGenerator(generatorOptions) {
    const {
        defaultModifiers = [],
        defaultOptions = DEFAULT_OPTIONS,
    } = generatorOptions;
    return createPopper(referance,popper,options){
        let state = {
            // ...some code
        };
        let effectCleanupFns = [];
        let isDestroyed = false;
        const instance = {
            state,
            setOptions(){
                // ...some code
                cleanupModifierEffects();
                // ...some code
                runModifierEffects();
                return instance.update();
            },
            forceUpdate(){
                // ...some code
            },
            update(){
                return new Promise(resolve) => {
                    instance.forceUpdate()
                    resolve(state);
                }
            },            
            destory(){
                // ...some code
            },
        }
        instance.setOptions(options).then(state) => {
            if (!isDestroyed && options.onFirstUpdate) {
                options.onFirstUpdate(state);
            }
        }
        function runModifierEffects(){
            // ...some code 
        }
        function cleanupModifierEffects(){
            // ...some code 
        }
        return instance;
    }
}
```

åˆ©ç”¨`popperGenerator`åˆå§‹åŒ–äº†ä¸€äº› `modifiers`ã€`options`ï¼Œç”Ÿæˆ`createPopper`å‡½æ•°å¿…å¤‡çš„ä¸€äº›å‚æ•°ï¼Œå½“æ‰§è¡Œ`createPopper`æ—¶ï¼Œ`setOptions` -> `cleanupModifierEffects()` -> `runModifierEffects()` -> `update` -> `forceUpdate()`ã€‚ä¸ä»…ä»…å¯ä»¥åˆ©ç”¨`createPopper`æ¥ç›´æ¥ä½¿ç”¨ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥åˆ©ç”¨`popperGenerator`æ¥è‡ªå®šä¹‰ `popper` æ›´æ–°ç­–ç•¥ã€‚æ•´ä½“ä»£ç æ‰§è¡Œé¡ºåºåŠè®¾è®¡ååˆ†å·§å¦™ï¼Œåˆ©ç”¨`effect`å¤„ç†å‰¯ä½œç”¨ï¼Œç„¶åé¡ºåºæ‰§è¡Œ `Modifier[fn]`æ¥è®¡ç®—ã€ç”Ÿæˆã€æ£€æµ‹æ˜¯å¦æº¢å‡ºç­‰ã€‚

### åˆå§‹åŒ–

#### setOptions

åˆå§‹åŒ–æ—¶æ‰§è¡Œä¸€æ¬¡ `setOptions`
```js
setOptions(){
  // ...some code 
  cleanupModifierEffects();
  // ...some code
  runModifierEffects();
  return instance.update();
},
```
`runModifierEffects` å’Œ `cleanupModifierEffects` å…¶åŠŸèƒ½ç±»ä¼¼äº`react`çš„ `useEffect`ï¼ŒEffect å‰¯ä½œç”¨å‡½æ•°ï¼Œä¼šç›´æ¥æˆ–è€…é—´æ¥çš„å½±å“å…¶ä»–å‡½æ•°çš„æ‰§è¡Œã€‚

```js
// react useEffect
useEffect(()=>{
    // some code such as: addEventListener
    return ()=>{
        //some code such as: removeEventListener
    }
})
// popper.js
runModifierEffects(){
//   æ¯ä¸€ä¸ªmodifieræ‰§è¡Œ runModifierEffect
    state.orderedModifiers.forEach((modifier) => runModifierEffect(modifier);
}
runModifierEffect({ name, options = {}, effect }){
    if (typeof effect === 'function') {
                // æ‰§è¡Œ effect
                const cleanupFn = effect({ state, name, instance, options });
                const noopFn = () => {};
                // push effectçš„è¿”å›ç»“æœ
                effectCleanupFns.push(cleanupFn || noopFn);
            }
}
cleanupModifierEffects(){
    effectCleanupFns.forEach((fn) => fn());
    effectCleanupFns = [];
}
```

æœ‰æ²¡æœ‰å¾ˆåƒï¼Œæœ‰æ²¡æœ‰~ è¿˜æ²¡çœ‹å‡ºæ¥å—ï¼Œæ²¡å…³ç³»ï¼Œæˆ‘ä»¬åˆ©ç”¨ä»£å…¥æ³•ï¼Œç”¨ä¸€ä¸ªeventListenersModifieræ¥è¡¨è¾¾ä¸€ä¸‹è¿™é‡Œçš„å…³ç³»

```js
function effect({ state, instance, options }: ModifierArguments<Options>) {
  const { scroll = true, resize = true } = options;
  const window = getWindow(state.elements.popper);
  const scrollParents = [
    ...state.scrollParents.reference,
    ...state.scrollParents.popper,
  ];
  if (scroll) {
    scrollParents.forEach(scrollParent => {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }
  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }
  return () => {
    if (scroll) {
      scrollParents.forEach(scrollParent => {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }
    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
}
export default ({
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: () => {},
  effect,
  data: {},
}: EventListenersModifier);
```

å½“æ‰§è¡Œ `runMidifierEffects`æ—¶ï¼Œä¼šå¯¹ `scrollParent`æ·»åŠ `addEventListener`ã€å¯¹`window`æ·»åŠ `addEventListener`ï¼Œå½“æ‰§è¡Œ`clearnUpModifierEffects`æ—¶ï¼Œä¼šæ‰§è¡Œ`removeEventLIstener`æ¥ç§»é™¤äº‹ä»¶ç›‘å¬ã€‚

æœ€åï¼Œ`setOptions`è¿”å› `instance.update()`çš„æ‰§è¡Œç»“æœ

```js
update: debounce (() => new Promise < $Shape < State >> ((resolve) => {
                    instance.forceUpdate();
                    resolve(state);
                })
            ),
```

è¿™é‡ŒåŠ äº†ä¸€ä¸ªé˜²æŠ–ï¼Œé˜²æ­¢å¤šæ¬¡è§¦å‘ `forceUpdate()`ï¼Œæ¯”å¦‚è¯´åœ¨ä¸Šé¢çœ‹åˆ°çš„`EventListenersModifier`ï¼Œå½“è§¦å‘`scroll`ã€`resize`æ—¶ï¼Œå¯èƒ½ä¼šé¢‘ç¹è§¦å‘ `update`å‡½æ•°ï¼Œå¯¼è‡´å¤šæ¬¡æ‰§è¡Œï¼Œæ‰€ä»¥è¿™é‡ŒåŠ äº†é˜²æŠ–ã€‚

#### `forceUpdate`

```js
forceUpdate(){
    // destroyedæ ‡å¿—
    if (isDestroyed) {
        return;
    }
    const { reference, popper } = state.elements;
    //æ ¡éªŒ referenceã€popperå…ƒç´ æ˜¯å¦å¯ç”¨
    if (!areValidElements(reference, popper)) {
        return;
    }
    // å­˜å‚¨referenceå’Œpopper rectä»¥ä¾› modifiersè¯»å–
    state.rects = {
     reference: getCompositeRect(
                   reference,
                   getOffsetParent(popper),
                   state.options.strategy === 'fixed'
                ),
     popper: getLayoutRect(popper),
    };
    state.reset = false;
    state.placement = state.options.placements;
    // éå†orderedModifiers æ¯æ¬¡æ›´æ–°é‡æ–°å¡«å…… modifiersData
    state.orderedModifiers.forEach((modifier) =>
                    (state.modifiersData[modifier.name] = {
                        ...modifier.data,
                    })
                );
// éå†orderedModifiers å–å‡º modifier[fn] æ‰§è¡Œ
    for (let index = 0; index < state.orderedModifiers.length; index++) {
        if (state.reset === true) {
                state.reset = false;
                index = -1;
                continue;
            }
        const { fn, options = {}, name } = state.orderedModifiers[index];
        if (typeof fn === 'function') {
             state = fn({ state, options, name, instance }) || state;
             }
      }
}
```

##### Rects

1.  ##### `popper`

```js
// å­˜å‚¨referenceå’Œpopper rectä»¥ä¾› modifiersè¯»å–
state.rects = {
   // some code 
   popper: getLayoutRect(popper),
};
function getLayoutRect(element: HTMLElement): Rect {
  const clientRect = getBoundingClientRect(element);
  // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223
  let width = element.offsetWidth;
  let height = element.offsetHeight;
  // ç”±äºgetBoundingClientRectæ˜¯åŸºäº getClientRectsçš„ï¼Œmdnä¸­è¯´æ˜åˆ°ï¼Œå°æ•°çº§åˆ«çš„åƒç´ åç§»æ˜¯æœ‰å¯èƒ½çš„ã€‚è¿™é‡Œåšäº†ä¸€äº›å®¹é”™ã€‚
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    // è¿”å›elementè·ç¦»element.offsetParentçš„å·¦è¾¹ç•Œåç§»çš„åƒç´ å€¼
    x: element.offsetLeft,
    // åŒä¸Š
    y: element.offsetTop,
    width,
    height,
  };

}
```

1.  [getBoundingClientRect](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect)æ–¹æ³•è¿”å›å…ƒç´ å¤§å°åŠå…¶ç›¸å¯¹**è§†çª—(viewport)** çš„ä½ç½®ã€‚

> å¦‚æœæ˜¯æ ‡å‡†ç›’å­æ¨¡å‹ï¼Œå…ƒç´ çš„å°ºå¯¸ç­‰äº`width/height` + `padding` + `border-width`çš„æ€»å’Œã€‚å¦‚æœ`box-sizing: border-box`ï¼Œå…ƒç´ çš„çš„å°ºå¯¸ç­‰äº `width/height`ã€‚

> è¿”å›çš„ç»“æœæ˜¯åŒ…å«å®Œæ•´å…ƒç´ çš„æœ€å°çŸ©å½¢ï¼Œå¹¶ä¸”æ‹¥æœ‰`left`, `top`, `right`, `bottom`, `x`, `y`, `width`, å’Œ `height`è¿™å‡ ä¸ªä»¥åƒç´ ä¸ºå•ä½çš„åªè¯»å±æ€§ç”¨äºæè¿°æ•´ä¸ªè¾¹æ¡†ã€‚é™¤äº†`width` å’Œ `height` ä»¥å¤–çš„å±æ€§æ˜¯ç›¸å¯¹äºè§†å›¾çª—å£çš„å·¦ä¸Šè§’æ¥è®¡ç®—çš„ã€‚

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b304c760fc347719ca76ceae13944b7~tplv-k3u1fbpfcp-zoom-1.image)

2.  `offsetWidth / offsetHeight` = `width/height` + `padding` + `border-width`
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42e69676718f4083aa9717cdb428fba0~tplv-k3u1fbpfcp-zoom-1.image)

ç”±äº`getBoundingClientRect`æ˜¯åŸºäº getClientRectsçš„ï¼Œmdnä¸­è¯´æ˜åˆ°ï¼Œå°æ•°çº§åˆ«çš„åƒç´ åç§»æ˜¯æœ‰å¯èƒ½çš„ï¼Œæ‰€ä»¥åœ¨ä»£ç ä¸­åšäº†ä¸€äº›å®¹é”™åšäº†ä¸€äº›å®¹é”™ã€‚å…³äºClientRectæ˜¯ä»€ä¹ˆå¯ä»¥çœ‹è¿™é‡Œ [DomRect](https://developer.mozilla.org/en-US/docs/Web/API/DOMRect)ã€‚

3.  `offsetLeft/offsetTop`

è¿”å›å½“å‰å…ƒç´ å·¦ä¸Šè§’ç›¸å¯¹äº`offsetParent`å·¦è¾¹/ä¸Šè¾¹åç§»çš„åƒç´ å€¼

`offsetParent`å…ƒç´ åªå¯èƒ½æ˜¯ä¸‹é¢è¿™å‡ ç§æƒ…å†µï¼š

-   `<body>`

<!---->

-   `position`ä¸æ˜¯`static`çš„å…ƒç´ (position é»˜è®¤å€¼æ˜¯ `static`)

<!---->

-   `<table>`, `<th>` æˆ–`<td>`ï¼Œä½†å¿…é¡»è¦`position: static`ã€‚

å®é™…è¿™ä¸ª `getLayoutRect`è¿”å›äº† `popper` çš„ `width/height`å’Œ è·ç¦» `reference` çš„x,y(ä¸€èˆ¬æƒ…å†µä¸‹éƒ½æ˜¯é‡‡ç”¨position:absolute | fixed)

> æœ‰å…³æ›´å¤šå„ç§offsetXXXçš„å±æ€§å¯ä»¥çœ‹å¼ é‘«æ—­å¤§ä½¬çš„è¿™ç¯‡æ–‡ç«  [CSSOMè§†å›¾æ¨¡å¼(CSSOM View Module)ç›¸å…³æ•´ç† Â« å¼ é‘«æ—­-é‘«ç©ºé—´-é‘«ç”Ÿæ´»](https://www.zhangxinxu.com/wordpress/2011/09/cssom%e8%a7%86%e5%9b%be%e6%a8%a1%e5%bc%8fcssom-view-module%e7%9b%b8%e5%85%b3%e6%95%b4%e7%90%86%e4%b8%8e%e4%bb%8b%e7%bb%8d/) é‡Œé¢è¿˜è´´å¿ƒçš„é…å¤‡äº†å„ç§demoã€‚ç»™å¤§ä½¬ç‚¹èµï¼ï¼ï¼ã€‚

2.  ##### `reference`

```js
state.rects = {
   reference: getCompositeRect(
        reference,
        getOffsetParent(popper),
        state.options.strategy === 'fixed'
      ),
   // some code
        };
// è·å–ä¸€ä¸ªæ­£ç¡®çš„offsetParent é’ˆå¯¹ Element.offsetParentçš„ç‰¹æ®Šæƒ…å†µçº æ­£
function getOffsetParent(element: Element) {
  const window = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);
  while (
    offsetParent &&
    isTableElement(offsetParent) &&
    getComputedStyle(offsetParent).position === 'static'
  ) {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (
    offsetParent &&
    (getNodeName(offsetParent) === 'html' ||
      (getNodeName(offsetParent) === 'body' &&
        getComputedStyle(offsetParent).position === 'static'))
  ) {
    return window;
  }
  return offsetParent || getContainingBlock(element) || window;
}

getTrueOffsetParent(element: Element): ?Element {
  if (
    !isHTMLElement(element) ||
    // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle(element).position === 'fixed'
  ) {
    return null;
  }
  return element.offsetParent;

}
```

`getOffsetParent` å‡½æ•°è¿”å›å€¼ä¸º `offsetParent` | `window`ã€‚

```js
function getCompositeRect(
  elementOrVirtualElement: Element | VirtualElement,
  offsetParent: Element | Window,
  isFixed: boolean = false
): Rect {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const offsetParentIsScaled =
    isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  // å–åˆ° DomRect
  const rect = getBoundingClientRect(
    elementOrVirtualElement,
    offsetParentIsScaled
  );
  // ------------------å¼€å§‹è®¡ç®—scrollå’Œoffsets
  let scroll = { scrollLeft: 0, scrollTop: 0 };
  let offsets = { x: 0, y: 0 };
  if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {
    if (
      getNodeName(offsetParent) !== 'body' ||
      // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)
    ) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  // ------------------è®¡ç®—ç»“æŸ-------------------
  return {
   // left + scrollLeft - offsetParent.clientLeft
    x: rect.left + scroll.scrollLeft - offsets.x,
    // top + scrollTop - offsetParent.clientTop
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height,
  };
}
```

emmmm,è¿™é‡Œçš„x,yæˆ‘ä¹Ÿæ²¡çœ‹å¤ªæ‡‚ä¸ºå•¥è¦å‡å» `offset.x|y`ï¼Œæš‚æ—¶å°±å½“ä»–ä¸º0å§ã€‚ã€‚ã€‚ã€‚çœ‹äº†åŠå¤©å®é™…ä¸Šå°±æ˜¯è¿”å›äº†`reference`çš„`widthï¼Œheight`ä»¥åŠ`left+scrollLeft`å’Œ`top+scrollTop`

***

å¯ä»¥çœ‹å‡ºæ¥çš„æ˜¯ï¼Œæ¯æ¬¡updateæ—¶ï¼Œä¼šé‡æ–°è®¡ç®—rectsã€modifiersDataï¼Œé‡æ–°æ‰§è¡Œmodifier[fn]ã€‚

é€šè¿‡ä¸Šé¢çš„ä»£ç ï¼Œå¯ä»¥çœ‹å‡º ä¸åŒçš„Modifierä¸»è¦æ˜¯å½±å“äº†ä¸¤ä¸ªéƒ¨åˆ†

1.  effectçš„æ‰§è¡Œï¼Œä»…åœ¨setOptionsæ—¶æ‰§è¡Œï¼Œåªåœ¨generatoræ—¶ æ‰§è¡Œäº†ä¸€æ¬¡
1.  modifier[fn]çš„æ‰§è¡Œï¼Œä»…åœ¨Updateæ—¶æ‰§è¡Œã€‚updateçš„æ‰§è¡Œå¯ç”±effectæ¥æ§åˆ¶ã€‚æ¯æ¬¡è§¦å‘eventListeneréƒ½ä¼šæ‰§è¡Œã€‚

### Modifiers

#### Effect

```js
const defaultModifiers = [
  eventListeners,
  popperOffsets,
  computeStyles,
  applyStyles,
  offset,
  flip,
  preventOverflow,
  arrow,
  hide,
];
```

é»˜è®¤çš„Modifiersä¸­ï¼Œæ‹¥æœ‰effectå‡½æ•°çš„æœ‰ï¼Œ`eventListeners`ã€`applyStyles`ã€`arrow`ã€‚å…ˆæ¥çœ‹ä¸€ä¸‹è¿™ä¸‰ä¸ªModifierçš„effectå‡½æ•°åˆ†åˆ«åšäº†ä»€ä¹ˆã€‚

1.  ##### eventListeners
åœ¨å‰é¢å·²ç»çœ‹è¿‡äº†ï¼Œè¿™é‡Œå°±ä¸åšåˆ†æã€‚è¯¥æ–¹æ³•ä¸»è¦æ˜¯æ³¨å†Œç›‘å¬å™¨å’Œå–æ¶ˆç›‘å¬å™¨ã€‚

2.  ##### applyStyles

```js
function effect({ state }) {
  const initialStyles = {
    // åˆå§‹åŒ–initial popper styles
    popper: {
      position: state.options.strategy, // é»˜è®¤ä¸º absolute
      left: '0',
      top: '0',
      margin: '0',
    },
    // åˆå§‹åŒ– initial arrow
    arrow: {
      position: 'absolute',
    },
    // reference
    reference: {},
  };
  // åˆå¹¶ popper style
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  // åˆå¹¶ arrow style è®¾ç½®position
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  // clearnUp Fn
  return () => {
    Object.keys(state.elements).forEach((name) => {
      // å–å‡ºelement
      const element = state.elements[name];
      //  å–å‡º attribute
      const attributes = state.attributes[name] || {};
      // styleProperties
      const styleProperties = Object.keys(
        state.styles.hasOwnProperty(name)
          ? state.styles[name]
          : initialStyles[name]
      );
      // Set all values to an empty string to unset them
      const style = styleProperties.reduce((style, property) => {
        style[property] = '';
        return style;
      }, {});
      // arrow is optional + virtual elements
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      // ç§»é™¤applyçš„initalStyle
      Object.keys(attributes).forEach((attribute) => {
        element.removeAttribute(attribute);
      });
    });
  };
}
```

è¯¥æ–¹æ³•é’ˆå¯¹ `popper`å’Œ`arrow`åšäº†ä¸€äº›styleæ ·å¼çš„åˆå¹¶å’Œåˆ é™¤æ“ä½œ

3.  ##### Arrow

```js
// Specifies the element to position as the arrow. This element must be a child of the popper element.
// A string represents a CSS selector queried within the context of the popper element.
// Popper will automatically pick up the following element (using the data-popper-arrow attribute) and position it:
// arrow type = Element | String
function effect({ state, options }) {
  let { element: arrowElement = '[data-popper-arrow]' } = options;
  // è‹¥æ²¡æœ‰arrowElement return
  if (arrowElement == null) {
    return;
  }
  // CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  // arrow è®¾ç½®
  state.elements.arrow = arrowElement;
}
```
é€šè¿‡è¿™ä¸‰ä¸ª `effect`ï¼Œå¯ä»¥å‘ç°ï¼Œ`eventListeners`ä¸»è¦æ˜¯è®¾ç½®`update`æ›´æ–°æœºåˆ¶ï¼ŒapplyStylesä¸»è¦æ˜¯ merge `refenerce`ã€`popper`ã€`arrow`çš„styleã€‚`Arrow`ä¸»è¦æ˜¯è®¾ç½®å°ç®­å¤´çš„elementsã€‚

#### Modifier[fn]

é™¤`eventListeners`è¿™ä¸ªModifier ä¹‹å¤–ï¼Œå…¶ä»–çš„åŸºæœ¬ä¸Šéƒ½æœ‰fnæ–¹æ³•ï¼Œé€ä¸ªæ”»ç ´ï¼

è¿™é‡Œè¦æ³¨æ„çš„æ˜¯ï¼ŒModifieræ‰§è¡Œé¡ºåºæ˜¯ä¸å¯æ‰“ä¹±çš„ï¼Œåœ¨`setOptions`æ—¶ï¼Œæœ‰è¿™æ ·ä¸€æ®µä»£ç ,å°†é»˜è®¤çš„`modifiers`æ”¾ç½®åˆ°äº†æœ€å‰é¢ã€‚

```js
// defaultModifiers æ˜¯é»˜è®¤çš„Modifiers
const orderedModifiers = orderModifiers(
          mergeByName([...defaultModifiers, ...state.options.modifiers])
        );
```
1.  ##### popperOffsets

```js
function popperOffsets({ state, name }) {
  // offsets æ˜¯popperéœ€è¦è¢«æ­£ç¡®æ”¾ç½®åœ¨å‚è€ƒå…ƒç´ é™„è¿‘çš„å®é™…ä½ç½®ï¼Œ
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement,
  });
}
function computeOffsets({
  reference,
  element,
  placement,
}){
  // è·å– placement  'top' | 'bottom' | 'left' | 'right';
  const basePlacement = placement ? getBasePlacement(placement) : null;
  // è·å–æ–¹ä½ 'start' | 'end';
  const variation = placement ? getVariation(placement) : null;
  // åŸºå‡†åæ ‡ x å¯ä»¥ç†è§£ä¸º è·ç¦»é¡µé¢å·¦è¾¹çš„å®½åº¦ + referenceå®½åº¦ / 2 - (popperçš„å®½åº¦ / 2)
  const commonX = reference.x + reference.width / 2 - element.width / 2;
  // åŸºå‡†åæ ‡ y å¯ä»¥ç†è§£ä¸º è·ç¦»é¡µé¢ä¸Šè¾¹çš„å®½åº¦ + referenceé«˜åº¦ / 2 - (popperçš„é«˜åº¦ / 2)
  const commonY = reference.y + reference.height / 2 - element.height / 2;
  // åŸºæœ¬ä¸º reference ä¸­å¿ƒç‚¹ å‘å·¦ä¸Šåç§» [element.width / 2,element.height / 2];
  let offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height,
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height,
      };
      break;
    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY,
      };
      break;
    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY,
      };
      break;
    default:
      offsets = {
        x: reference.x,
        y: reference.y,
      };
  }
  const mainAxis = basePlacement
    ? getMainAxisFromPlacement(basePlacement)
    : null;
  if (mainAxis != null) {
    const len = mainAxis === 'y' ? 'height' : 'width';
    switch (variation) {
      case start:
        offsets[mainAxis] =
          offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] =
          offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}
```

ä»£ç è§£é‡Šèµ·æ¥çœ‹ä¸Šå»ä¸æ˜¯å¾ˆå¥½ç†è§£ï¼Œçœ‹å›¾

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abb7f98694d8401e834b5e10322fddd4~tplv-k3u1fbpfcp-zoom-1.image)

`offsets` å…ˆä¼šæ ¹æ®`basePlacement`è®¡ç®—å‡º 4ç§æƒ…å†µçš„å®šä½ **åŸºç‚¹ã€‚**

> åŸºç‚¹å°±æ˜¯ popper element å·¦ä¸Šè§’çš„é‚£ä¸ªç‚¹ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆoffsetçœ‹ä¸Šå»å¥‡å¥‡æ€ªæ€ªçš„ã€‚

å‡è®¾popper çš„ width å’Œ height å‡ä¸º 0ã€‚ æ˜¯ä¸æ˜¯å°±æ›´å®¹æ˜“ç†è§£äº†

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f121d8f6af6412588d18c09b0395689~tplv-k3u1fbpfcp-zoom-1.image)

ç„¶åæ ¹æ® `mainAxis`å’Œ`variation`ä¸»è½´(x | y)è®¡ç®— `start | end` çš„åç§»é‡ ã€‚

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3f48da7e9e44a358d04670eaaa58d88~tplv-k3u1fbpfcp-zoom-1.image)

æœ€ç»ˆç”Ÿæˆ `offsets:{x:number,y:number}`ï¼ŒåŸºç‚¹åæ ‡ï¼Œå°†å®ƒå­˜å‚¨è¿›å…¥ `modifiersData`ä¸­ã€‚å­—æ®µåä¸º `popperOffsets`ã€‚


2.  ##### computeStyles

ä¸»è¦è®¡ç®— `popper`ã€`arrow`çš„ style æ ·å¼ï¼Œå¼€å¯GPUåŠ é€Ÿ(ä½¿ç”¨transform)ï¼Œä¸€äº›è¯¯å·®çš„ç£¨å¹³ã€‚

```js
function computeStyles({ state, options }) {
  const {
    // gpuåŠ é€Ÿ é»˜è®¤å¼€å¯
    gpuAcceleration = true,
    // è‡ªé€‚åº” é»˜è®¤å¼€å¯
    adaptive = true,
    // defaults to use builtin `roundOffsetsByDPR`
    roundOffsets = true,
  } = options;
  
  const commonStyles = {
    // topã€bottomã€startã€end
    placement: getBasePlacement(state.placement),
    // startã€end
    variation: getVariation(state.placement),
    // element
    popper: state.elements.popper,
    // updateä¸­ç”Ÿæˆçš„ rect
    popperRect: state.rects.popper,
    // gpuåŠ é€Ÿ
    gpuAcceleration,
    isFixed: state.options.strategy === 'fixed',
  };
  // åœ¨popperOffsetsä¸­ç”Ÿæˆçš„
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = {
      ...state.styles.popper,
      ...mapToStyles({
        ...commonStyles,
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets,
      }),
    };
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = {
      ...state.styles.arrow,
      ...mapToStyles({
        ...commonStyles,
        offsets: state.modifiersData.arrow,
        position: 'absolute',
        adaptive: false,
        roundOffsets,
      }),
    };
  }
  state.attributes.popper = {
    ...state.attributes.popper,
    'data-popper-placement': state.placement,
  };
}

function mapToStyles({popper,popperRect,placement,variation,offsets,position,gpuAcceleration,adaptive,roundOffsets,isFixed,}) 
{
  // offsets æ¥è‡ªäº popperOffsets ä¸­ç”Ÿæˆ
  let { x = 0, y = 0 } = offsets;
  const hasX = offsets.hasOwnProperty('x');
  const hasY = offsets.hasOwnProperty('y');
  let sideX: string = left;
  let sideY: string = top;
  const win: Window = window;
  // è‡ªé€‚åº”å¤„ç†é€»è¾‘ å­˜åœ¨ä¸€äº› styleçš„å˜æ¢
  if (adaptive) {
    // ... some code 
  }
  // ç»è¿‡è‡ªé€‚åº”å¤„ç†è¿‡åçš„style
  const commonStyles = {
    position,
    ...(adaptive && unsetSides),
  };
    // é»˜è®¤ä¸º true è‡ªå®šä¹‰å–æ¶ˆè¯¯å·®å‡½æ•°
  ({ x, y } =
    typeof roundOffsets === 'function'
      ? roundOffsets({ x, y })
      : { x, y });
  // å–æ¶ˆè¯¯å·® å› ä¸ºä¸åŒåˆ†è¾¨ç‡ä¸‹å¯èƒ½ä¼šå­˜åœ¨ä¸€äº›è¯¯å·®è€Œå¯¼è‡´æ¸²æŸ“é”™ä½ï¼Œé€šå¸¸ä¼šæœ‰<1pxçš„è¯¯å·®
  ({ x, y } =
    roundOffsets === true
      ? roundOffsetsByDPR({ x, y })
      : { x, y });
  // å¦‚æœå¼€å¯gpuåŠ é€Ÿçš„è¯ ä½¿ç”¨transform
  if (gpuAcceleration) {
    return {
      ...commonStyles,
      [sideY]: hasY ? '0' : '',
      [sideX]: hasX ? '0' : '',
      // Layer acceleration can disable subpixel rendering which causes slightly
      // blurry text on low PPI displays, so we want to use 2D transforms
      // instead
      transform:
        (win.devicePixelRatio || 1) <= 1
          ? `translate(${x}px, ${y}px)`
          : `translate3d(${x}px, ${y}px, 0)`,
    };
  }
  // ä¸å¼€å¯gpuåŠ é€Ÿè¿”å›å¾—ç»“æœ
  return {
    ...commonStyles,
    [sideY]: hasY ? `${y}px` : '',
    [sideX]: hasX ? `${x}px` : '',
    transform: '',
  };
}
```

3.  ##### applyStyles

å°† `popper`ã€`arrow`ã€`reference`ç­‰åŸæœ‰çš„ style å’Œ attribute ä¸ `computeSytles` ä¸­è®¡ç®—å‡ºçš„ style æ ·å¼è¿›è¡Œåˆå¹¶ã€‚

```js
function applyStyles({ state }: ModifierArguments<{||}>) {
  // å–å‡º referenceã€ popperã€arrow è®¾ç½® styleã€attributesç­‰
  Object.keys(state.elements).forEach((name) => {
    const style = state.styles[name] || {};
    const attributes = state.attributes[name] || {};
    const element = state.elements[name];
    // arrow is optional + virtual elements
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]
    Object.assign(element.style, style);
    // é’ˆå¯¹ attribute ç‰¹æ®Šå¤„ç†
    Object.keys(attributes).forEach((name) => {
      const value = attributes[name];
      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
     }
    });
  });
}
```

4.  ##### Offsets

**æ³¨ï¼šè¿™é‡Œçš„offsetsæŒ‡çš„æ˜¯ç”¨æˆ·è‡ªå®šä¹‰çš„ä¸€äº›åç§»é‡ï¼Œè€Œä¸æ˜¯è®¡ç®—å¾—å‡ºçš„ `popperOffsets`ã€‚**

```js
function offset({ state, options, name }: ModifierArguments<Options>) {
  // optionsä¼ å…¥çš„å‚æ•° [0,0] å¯ä»¥ç†è§£ä¸ºç”¨æˆ·è‡ªå®šä¹‰é¢å¤–çš„åç§»é‡
  const { offset = [0, 0] } = options;
  // ç”±äºæ¥ä¸‹æ¥çš„æº¢å‡ºæ£€æµ‹ï¼Œè‡ªåŠ¨åˆ‡æ¢ä½ç½®å¯èƒ½ä¼šéœ€è¦å…¶ä»–æ–¹å‘çš„åç§»é‡ï¼Œæ‰€ä»¥è¿™è¾¹ä¸€æ¬¡æ€§æ‰€æœ‰æ–¹ä½å…¨éƒ¨ç”Ÿæˆï¼Œè€Œé¿å…äº†æ¯æ¬¡è®¡ç®—ï¼Œæ¯æ¬¡ç”Ÿæˆã€‚
  const data = placements.reduce((acc, placement) => {
    // æ ¹æ®placementsç”Ÿæˆ æ¯ä¸ªæ–¹ä½çš„åç§»é‡
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  const { x, y } = data[state.placement];
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  // æ›´æ–° modifiersData popperOffsets
  state.modifiersData[name] = data;
}
```
5.  ##### flip

```js
function flip({ state, options, name }) {
    // flip skip    
    if (state.modifiersData[name]._skip) {
        return;
    }
    // 
    const {
        mainAxis: checkMainAxis = true,
        altAxis: checkAltAxis = true,
        // é»˜è®¤å¯ä¾›å°è¯•çš„placements
        fallbackPlacements: specifiedFallbackPlacements,
        // ä¼šå¯¹boundaryè¾¹ç•Œè¿›è¡Œè™šæ‹Ÿå¡«å……
        padding,
        // popper
        boundary,
        // reference
        rootBoundary,
        // arrow
        altBoundary,
        // top-start => top-end å°è¯•ç¿»è½¬å˜åŒ–
        flipVariations = true,
        allowedAutoPlacements,
    } = options;
    // custom placement??
    const preferredPlacement = state.options.placement;
    // 'top-start' => 'top'
    const basePlacement = getBasePlacement(preferredPlacement);
    const isBasePlacement = basePlacement === preferredPlacement;
    // è·å– å½“å‘ç”Ÿæº¢å‡ºæ—¶ï¼Œå¯ä¾›å°è¯•çš„Placementsï¼Œé»˜è®¤æƒ…å†µä¸‹åº”è¯¥ä¸º specifiedFallbackPlacementsï¼Œ
    //è‹¥æ²¡æœ‰ specifiedFallbackPlacements åˆ™æ ¹æ®placementæ¥ç”ŸæˆfallbackPlacements
    const fallbackPlacements =
        specifiedFallbackPlacements ||
        (isBasePlacement || !flipVariations ?
            [getOppositePlacement(preferredPlacement)] :
            getExpandedFallbackPlacements(preferredPlacement));
    // ç”Ÿæˆçš„placements
    const placements = [preferredPlacement, ...fallbackPlacements].reduce(
        (acc, placement) => {
            return acc.concat(
                // å½“placementä¸º 'auto'æ—¶ï¼Œè‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªå¯èƒ½èƒ½ç”¨çš„placement
                getBasePlacement(placement) === auto ?
                computeAutoPlacement(state, {
                    placement,
                    boundary,
                    rootBoundary,
                    padding,
                    flipVariations,
                    allowedAutoPlacements,
                }) :
                placement
            );
        }, []
    );
}
```

[fallbackPlacementsæœ‰å…³çš„ä¸€äº›è¯´æ˜](https://popper.js.org/docs/v2/modifiers/flip/#fallbackplacements)ï¼Œå‡è®¾æˆ‘ä»¬åŸæœ‰çš„`placement`è®¾ç½®ä¸º`button`ï¼Œå½“æ²¡æœ‰è¶³å¤Ÿçš„ç©ºé—´æ¥å®¹çº³å®ƒæ—¶ï¼Œä¼šä½¿ç”¨`fallbackPlacements`ä¸­çš„å‚æ•°æ¥è¿›è¡Œå°è¯•ã€‚`pacements` æœ‰ä¸‹é¢ä¸‰ç§æƒ…å†µï¼š
-   `specifiedFallbackPlacements`å‚æ•°ï¼Œåˆ™ç›´æ¥ä½¿ç”¨å‚æ•°ï¼Œ
-   æ˜¯`basePlacement(top | left | right | bottom)`ï¼Œåˆ™ä¼šå–åï¼Œä¾‹å¦‚ åŸæ¥æ˜¯`top`ï¼Œå–åä¼šæ˜¯ `bottom`
-   `æ˜¯ top-start`ï¼Œä¼šå…ˆå°è¯• `top-end`ã€`bottom-start`ã€`bottom-end`è¿™ä¸‰ç§æƒ…å†µã€‚
-   æ˜¯ `auto`ï¼Œåˆ™æ‰§è¡Œ `computeAutoPlacement`è¿›è¡Œè®¡ç®—ã€‚

```js
    const referenceRect = state.rects.reference;
    const popperRect = state.rects.popper;
    const checksMap = new Map();
    let makeFallbackChecks = true;
    let firstFittingPlacement = placements[0];
    // å¼€å§‹ç”ŸæˆchecksMap
    for (let i = 0; i < placements.length; i++) {
        const placement = placements[i];
        const basePlacement = getBasePlacement(placement);
        const isStartVariation = getVariation(placement) === start;
        // æ–¹å‘ x | y
        const isVertical = [top, bottom].indexOf(basePlacement) >= 0;
        
        // æ£€æµ‹æº¢å‡º 
        const overflow = detectOverflow(state, {
            placement,
            boundary,
            rootBoundary,
            altBoundary,
            padding,
        });
```
è¿™é‡Œçš„æ˜¯ ç»è¿‡ `detectOverflow`å‡½æ•°ï¼Œç”Ÿæˆäº† `overflow`ï¼Œåˆ©ç”¨ `overflow` æ¥åˆ¤æ–­å¯ç”¨çš„` placement`ã€‚çœ‹ä¸€ä¸‹ `detectOverflow`æ˜¯å¦‚ä½•æ£€æµ‹æº¢å‡ºçš„ã€‚

```js
function detectOverflow(state,option){
  const {
    placement = state.placement,
    boundary = clippingParents,
    rootBoundary = viewport,
    // flipè°ƒç”¨æ—¶ï¼Œæ²¡æœ‰ä¼ å…¥elementContextï¼Œä¸ºé»˜è®¤å€¼
    elementContext = popper,
    // true => reference || false => popper
    altBoundary = false,
    // padding æ£€æµ‹è·ç¦»ï¼Œç”¨æˆ·ä¼ å…¥å‚æ•°
    padding = 0,
  } = options;
  // æ ¹æ®paddingå’Œ basePlacementsç”Ÿæˆ 
  // paddingObjectï¼Œé»˜è®¤æ˜¯{top:0,left:0,right:0,bottom:0}
  // å‡è®¾padding = 10,åˆ™ä¸º {top:10,left:10,right:10,bottom:10}
  const paddingObject = mergePaddingObject(
    typeof padding !== 'number'
      ? padding
      : expandToHashMap(padding, basePlacements)
  );
  // altContext åœ¨flipè°ƒç”¨æ—¶ é»˜è®¤ä¸º reference
  const altContext = elementContext === popper ? reference : popper;
  const popperRect = state.rects.popper;
  // element é»˜è®¤ä¸º popper
  const element = state.elements[altBoundary ? altContext : elementContext];
  // ç”Ÿæˆä¸€ä¸ªclippingclient {width,height,x,y} // è¿™ä¸ªclippingclientRecté»˜è®¤æƒ…å†µä¸‹æŒ‡çš„æ˜¯çˆ¶èŠ‚ç‚¹çš„æ»šåŠ¨åŒºåŸŸå¤§å°æˆ–è€…æ˜¯ viewportå¤§å°
  // åŸæœ‰çš„æ³¨é‡Šï¼šGets the maximum area that the element is visible in due to any number of clipping parents
  const clippingClientRect = getClippingRect(
    isElement(element)
      ? element
      : element.contextElement || getDocumentElement(state.elements.popper),
    boundary, // clippingParents
    rootBoundary // viewport
  );
// æµè§ˆå™¨ä¸­çš„ çœŸæ­£å¤§å°, getBoundingClientRectå‡½æ•°é‡å†™äº†element. getBoundingClientRectï¼Œå…¶ä¸­å¯¹é¡µé¢çš„ç¼©æ”¾åŠä¸€äº›element.getBoundingClientRecté”™è¯¯æƒ…å†µåšäº†å®¹é”™å¤„ç†ã€‚è¿™é‡Œå¯ä»¥ç›´æ¥ç†è§£ä¸ºelement.getBoundingClientRectçš„è¿”å›å€¼
  const referenceClientRect = getBoundingClientRect(state.elements.reference);
  // computeOffsets åœ¨popperOffsetsä¸­ç”¨åˆ°è¿‡ï¼Œè¿™é‡Œå°±ä¸åšè¯´æ˜äº†ï¼Œä¼šç”Ÿæˆä¸€ä¸ªåŸºç‚¹åæ ‡
  const popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement,
  });
  æ ¹æ®å¾—åˆ°çš„åŸºç‚¹åæ ‡ï¼Œç”Ÿæˆæ–°çš„ popperClientRect
  const popperClientRect = rectToClientRect({
    ...popperRect,
    ...popperOffsets,
  });
  // elementClientRecté»˜è®¤å€¼ä¸º popperClientRect
  const elementClientRect =
    elementContext === popper ? popperClientRect : referenceClientRect;
  // å››ä¸ªæ–¹å‘æ£€æµ‹æ˜¯å¦æœ‰æº¢å‡ºï¼Œå¦‚æœæœ‰æº¢å‡ºçš„è¯ï¼Œä¾‹å¦‚ï¼štop:10,
  const overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom:
      elementClientRect.bottom -
      clippingClientRect.bottom +
      paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right:
      elementClientRect.right - clippingClientRect.right + paddingObject.right,
  };
   // è·å–åœ¨offsetsç”Ÿæˆçš„offsetData
  const offsetData = state.modifiersData.offset;
  // Offsets can be applied only to the popper element
  if (elementContext === popper && offsetData) {
    const offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach((key) => {
      const multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      const axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }
  return overflowOffsets;
}
```
ä»£ç æœ‰ç‚¹å¤æ‚ï¼Œæ¥åˆ†æä¸€ä¸‹`detectOverflow`å‡½æ•°åšäº†ä»€ä¹ˆ
1. æ ¹æ® `padding` ç”Ÿæˆ `paddingObject`ï¼Œ
2. åˆ¤æ–­æ˜¯æ£€æµ‹ `popper`è¿˜æ˜¯ `reference`ï¼Œç”Ÿæˆ`altContext`
3. æ ¹æ®`altContext`ï¼Œç”Ÿæˆ `clippingClientRect`,è¯¥å˜é‡é»˜è®¤æƒ…å†µä¸‹æ˜¯çˆ¶èŠ‚ç‚¹æ»šåŠ¨åŒºåŸŸçš„å¤§å°æˆ–è€… viewportçš„å¯è§†åŒºåŸŸå¤§å°,ä¸º`altContext`å¯è§çš„æœ€å¤§åŒºåŸŸ
4. `elementClientRect` ä¸º **æ­¤æ—¶æ­¤åˆ»**ï¼Œ`reference.getBoundingClientRect()`æˆ–è€… `popperClientRect`
5. ç”Ÿæˆ `overflowOffsets`ï¼Œä¸¾ä¾‹ï¼š`top`ä¸º `clippingClientRect.top` - `elementClientRect.top` + `paddingObject.top`ï¼Œæ­£å¸¸æƒ…å†µä¸‹è‹¥å¯ç”¨ä¸ºè´Ÿæ•°


æœ€ç»ˆï¼Œæˆ‘ä»¬è¿”å›äº†`overflowOffsets`ï¼Œå®ƒåŒ…å«äº†4ä¸ªæ–¹ä½æ˜¯å¦æœ‰æº¢å‡ºçš„æƒ…å†µã€‚ç›®å‰ï¼Œæˆ‘ä»¬ä»…åˆ†æé»˜è®¤æƒ…å†µï¼Œä¼ å‚æƒ…å†µæš‚ä¸è€ƒè™‘ã€‚

```js
        // åˆ†åŒº
        // right:top-startã€bottom-start
        // left:top-endã€bottom-end
        // bottom:left-startã€right-start
        // top:left-endã€right-end
        let mainVariationSide: any = isVertical ?
            (isStartVariation ?
              right :
              left ):
            (isStartVariation ?
              bottom :
              top);
        const len = isVertical ? 'width' : 'height';
        // è‹¥ reference width | height > popper å–åå‘ï¼Œæ²¡å¤ªæƒ³é€šä¸ºä»€ä¹ˆè¦å–åå‘
        // åˆšåˆšå¾—åˆ°çš„rightä¼šå˜æˆ left
        if (referenceRect[len] > popperRect[len]) {
            mainVariationSide = getOppositePlacement(mainVariationSide);
        }
        
        const altVariationSide: any = getOppositePlacement(mainVariationSide);
        const checks = [];
        // è¿™é‡Œéœ€è¦æ³¨æ„æ­£æ•°ä¸ºä¸å¯ç”¨ï¼Œè´Ÿæ•°|| 0 ä¸ºå¯ç”¨,è¿˜æœ‰ç©ºé—´
        if (checkMainAxis) {
            checks.push(overflow[basePlacement] <= 0);
        }
        if (checkAltAxis) {
            checks.push(
                overflow[mainVariationSide] <= 0,
                overflow[altVariationSide] <= 0
            );
        }
        // è‹¥æœ‰ä¸€ä¸ªå¯ç”¨çš„ä½ç½®
        if (checks.every((check) => check)) {
            firstFittingPlacement = placement;
            makeFallbackChecks = false;
            break;
        }
        checksMap.set(placement, checks);
    }
    // å¦‚æœæ²¡æœ‰å¯ç”¨çš„placement
    if (makeFallbackChecks) {
        // `2` may be desired in some cases â€“ research later
        const numberOfChecks = flipVariations ? 3 : 1;
        for (let i = numberOfChecks; i > 0; i--) {
            const fittingPlacement = placements.find((placement) => {
                const checks = checksMap.get(placement);
                if (checks) {
                    return checks.slice(0, i).every((check) => check);
                }
            });
            if (fittingPlacement) {
                firstFittingPlacement = fittingPlacement;
                break;
            }
        }
    }
    // è‹¥placementä¸é¢„è®¾çš„ä¸åŒï¼Œåˆ™_skipä¸ºtrueã€‚
    if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
    }
```

Flip æ˜¯è¿™æ ·ï¼Œæ•´ä½“æ‰§è¡Œæµç¨‹å¤§è‡´ä¸ºï¼Œè®¾ç½®ä¸€äº›`placements`ï¼Œæ£€æµ‹`popper`å››ä¸ªæ–¹å‘ï¼Œæ ¹æ®`placements`å’Œ`overflowOffsets`æ¥æ¨ç®—å“ªä¸ªplacementså¯ä»¥ä½¿ç”¨ï¼Œå¦‚æœæŸä¸€ä¸ªå¯ä»¥ä½¿ç”¨ï¼Œç»“æŸé€€å‡ºå‡½æ•°ã€‚

6.  ##### preventOverflow
è¿™éƒ¨åˆ†å®åœ¨æ˜¯æ‡’å¾—å†™äº†ï¼ŒQAQã€‚ç®€å•ä»‹ç»ä¸€ä¸‹ä»–çš„ä½œç”¨ï¼Œè®¡ç®—å‡ºreferenceåœ¨ä»€ä¹ˆæƒ…å†µä¸‹åº”è¯¥ç®—æº¢å‡ºï¼Œç„¶åè®°å½•ä¸‹è¿™ä¸ªå€¼ï¼Œä»¥ä¾¿åé¢ä½¿ç”¨

7.  ##### Arrow
```js
function arrow({ state, name, options }: ModifierArguments<Options>) {
  // 
  const arrowElement = state.elements.arrow;
  // 
  const popperOffsets = state.modifiersData.popperOffsets;
  // top/bottom/left/right
  const basePlacement = getBasePlacement(state.placement);
  // top/bottom => x left/right => y
  const axis = getMainAxisFromPlacement(basePlacement);
  const isVertical = [left, right].indexOf(basePlacement) >= 0;
  const len = isVertical ? 'height' : 'width';
  // è‹¥æ— arrowå…ƒç´ æˆ–è€… æ— popperçš„offset
  if (!arrowElement || !popperOffsets) {
    return;
  }
  // è¾¹è·
  const paddingObject = toPaddingObject(options.padding, state);
  const arrowRect = getLayoutRect(arrowElement);
  const minProp = axis === 'y' ? top : left;
  const maxProp = axis === 'y' ? bottom : right;
  const endDiff =
    state.rects.reference[len] +
    state.rects.reference[axis] -
    popperOffsets[axis] -
    state.rects.popper[len];
  const startDiff = popperOffsets[axis] - state.rects.reference[axis];
  const arrowOffsetParent = getOffsetParent(arrowElement);
  const clientSize = arrowOffsetParent
    ? axis === 'y'
      ? arrowOffsetParent.clientHeight || 0
      : arrowOffsetParent.clientWidth || 0
    : 0;
  const centerToReference = endDiff / 2 - startDiff / 2;
  // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds
  const min = paddingObject[minProp];
  const max = clientSize - arrowRect[len] - paddingObject[maxProp];
  const center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  const offset = within(min, center, max);
  // Prevents breaking syntax highlighting...
  const axisProp: string = axis;
  state.modifiersData[name] = {
    [axisProp]: offset,
    centerOffset: offset - center,
  };
```
è®¡ç®—å‡ºarrowçš„ä½ç½®ã€‚
8.  ##### hide

```js
function hide({ state, name }: ModifierArguments<{||}>) {
  const referenceRect = state.rects.reference;
  const popperRect = state.rects.popper;
  const preventedOffsets = state.modifiersData.preventOverflow;
  // referenceOverflowæ˜¯å¦æº¢å‡º
  const referenceOverflow = detectOverflow(state, {
    elementContext: 'reference',
  });
  // popperæ˜¯å¦æº¢å‡º
  const popperAltOverflow = detectOverflow(state, {
    altBoundary: true,
  });
  const referenceClippingOffsets = getSideOffsets(
    referenceOverflow,
    referenceRect
  );
  const popperEscapeOffsets = getSideOffsets(
    popperAltOverflow,
    popperRect,
    preventedOffsets
  );
  const isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  const hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped,
  };
  state.attributes.popper = {
    ...state.attributes.popper,
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped,
  };
}
```

åˆ†åˆ«åˆ¤æ–­äº†ï¼Œ`reference` å’Œ`popper`æ˜¯å¦æº¢å‡ºï¼Œå¦‚æœæº¢å‡ºçš„è¯ï¼Œåˆ™hideã€‚
### End 

ç¬¬äºŒå¼¹åˆ°æ­¤ç»“æŸäº†ï¼Œæœ‰å…³popper.jsä»…åˆ†ä¸º2ç¯‡ï¼Œè¿™æ˜¯ç¬¬2ç¯‡ã€‚è¯¥æ–‡ç« ä»…æ˜¯æˆ‘ä¸ªäººçš„ä¸€äº›ç†è§£ï¼Œéš¾å…æœ‰ä¸€äº›ä¸å¯¹çš„åœ°æ–¹ï¼Œæ¬¢è¿å¤§å®¶æ‰¹è¯„æŒ‡æ­£ï¼ï¼ï¼ å¦‚æœå¯ä»¥çš„è¯ï¼Œå ç”¨ä½ ä¸€äº›æ—¶é—´ï¼Œå¸®æˆ‘ç‚¹ä¸ªèµå§ğŸ‘ğŸ»ğŸ‘ğŸ»ğŸ‘ğŸ»ğŸ‘ğŸ»ğŸ‘ğŸ»ğŸ‘ğŸ»~
