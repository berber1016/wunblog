## 前言

作为前端，`popper.js`是绕不过去的一道坎，它作为底层组件，帮助我们解决了 `Tooltip`、`dropdown`、`Menu`等等一系列组件。几乎所有的这样的组件都是基于`Popper.js`组件来构成的。它的核心只有6000 byte左右，并且支持`tree-shaking`，支持自定义中间件、支持任意框架(基于 `JavaScript`)。

> 当前是基于v2.x分支作为分析，仅针对2.x分支分析。最新版本的popper.js已经更名为floating-ui。

## 基本逻辑

```js
const defaultModifiers = [
  eventListeners,
  popperOffsets,
  computeStyles,
  applyStyles,
  offset,
  flip,
  preventOverflow,
  arrow,
  hide,
];
const createPopper = popperGenerator({ defaultModifiers });
```

popper.js 利用 `popperGenerator`来生成 `createPopper` 函数，其中初始化了一些中间件。

```js
const DEFAULT_OPTIONS = {
    placement: 'bottom',
    modifiers: [],
    strategy: 'absolute',
}
function popperGenerator(generatorOptions) {
    const {
        defaultModifiers = [],
        defaultOptions = DEFAULT_OPTIONS,
    } = generatorOptions;
    return createPopper(referance,popper,options){
        let state = {
            // ...some code
        };
        let effectCleanupFns = [];
        let isDestroyed = false;
        const instance = {
            state,
            setOptions(){
                // ...some code
                cleanupModifierEffects();
                // ...some code
                runModifierEffects();
                return instance.update();
            },
            forceUpdate(){
                // ...some code
            },
            update(){
                return new Promise(resolve) => {
                    instance.forceUpdate()
                    resolve(state);
                }
            },            
            destory(){
                // ...some code
            },
        }
        instance.setOptions(options).then(state) => {
            if (!isDestroyed && options.onFirstUpdate) {
                options.onFirstUpdate(state);
            }
        }
        function runModifierEffects(){
            // ...some code 
        }
        function cleanupModifierEffects(){
            // ...some code 
        }
        return instance;
    }
}
```

利用`popperGenerator`初始化了一些 `modifiers`、`options`，生成`createPopper`函数必备的一些参数，当执行`createPopper`时，`setOptions` -> `cleanupModifierEffects()` -> `runModifierEffects()` -> `update` -> `forceUpdate()`。不仅仅可以利用`createPopper`来直接使用，我们还可以利用`popperGenerator`来自定义 `popper` 更新策略。整体代码执行顺序及设计十分巧妙，利用`effect`处理副作用，然后顺序执行 `Modifier[fn]`来计算、生成、检测是否溢出等。

### 初始化

#### setOptions

初始化时执行一次 `setOptions`
```js
setOptions(){
  // ...some code 
  cleanupModifierEffects();
  // ...some code
  runModifierEffects();
  return instance.update();
},
```
`runModifierEffects` 和 `cleanupModifierEffects` 其功能类似于`react`的 `useEffect`，Effect 副作用函数，会直接或者间接的影响其他函数的执行。

```js
// react useEffect
useEffect(()=>{
    // some code such as: addEventListener
    return ()=>{
        //some code such as: removeEventListener
    }
})
// popper.js
runModifierEffects(){
//   每一个modifier执行 runModifierEffect
    state.orderedModifiers.forEach((modifier) => runModifierEffect(modifier);
}
runModifierEffect({ name, options = {}, effect }){
    if (typeof effect === 'function') {
                // 执行 effect
                const cleanupFn = effect({ state, name, instance, options });
                const noopFn = () => {};
                // push effect的返回结果
                effectCleanupFns.push(cleanupFn || noopFn);
            }
}
cleanupModifierEffects(){
    effectCleanupFns.forEach((fn) => fn());
    effectCleanupFns = [];
}
```

有没有很像，有没有~ 还没看出来吗，没关系，我们利用代入法，用一个eventListenersModifier来表达一下这里的关系

```js
function effect({ state, instance, options }: ModifierArguments<Options>) {
  const { scroll = true, resize = true } = options;
  const window = getWindow(state.elements.popper);
  const scrollParents = [
    ...state.scrollParents.reference,
    ...state.scrollParents.popper,
  ];
  if (scroll) {
    scrollParents.forEach(scrollParent => {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }
  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }
  return () => {
    if (scroll) {
      scrollParents.forEach(scrollParent => {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }
    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
}
export default ({
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: () => {},
  effect,
  data: {},
}: EventListenersModifier);
```

当执行 `runMidifierEffects`时，会对 `scrollParent`添加`addEventListener`、对`window`添加`addEventListener`，当执行`clearnUpModifierEffects`时，会执行`removeEventLIstener`来移除事件监听。

最后，`setOptions`返回 `instance.update()`的执行结果

```js
update: debounce (() => new Promise < $Shape < State >> ((resolve) => {
                    instance.forceUpdate();
                    resolve(state);
                })
            ),
```

这里加了一个防抖，防止多次触发 `forceUpdate()`，比如说在上面看到的`EventListenersModifier`，当触发`scroll`、`resize`时，可能会频繁触发 `update`函数，导致多次执行，所以这里加了防抖。

#### `forceUpdate`

```js
forceUpdate(){
    // destroyed标志
    if (isDestroyed) {
        return;
    }
    const { reference, popper } = state.elements;
    //校验 reference、popper元素是否可用
    if (!areValidElements(reference, popper)) {
        return;
    }
    // 存储reference和popper rect以供 modifiers读取
    state.rects = {
     reference: getCompositeRect(
                   reference,
                   getOffsetParent(popper),
                   state.options.strategy === 'fixed'
                ),
     popper: getLayoutRect(popper),
    };
    state.reset = false;
    state.placement = state.options.placements;
    // 遍历orderedModifiers 每次更新重新填充 modifiersData
    state.orderedModifiers.forEach((modifier) =>
                    (state.modifiersData[modifier.name] = {
                        ...modifier.data,
                    })
                );
// 遍历orderedModifiers 取出 modifier[fn] 执行
    for (let index = 0; index < state.orderedModifiers.length; index++) {
        if (state.reset === true) {
                state.reset = false;
                index = -1;
                continue;
            }
        const { fn, options = {}, name } = state.orderedModifiers[index];
        if (typeof fn === 'function') {
             state = fn({ state, options, name, instance }) || state;
             }
      }
}
```

##### Rects

1.  ##### `popper`

```js
// 存储reference和popper rect以供 modifiers读取
state.rects = {
   // some code 
   popper: getLayoutRect(popper),
};
function getLayoutRect(element: HTMLElement): Rect {
  const clientRect = getBoundingClientRect(element);
  // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223
  let width = element.offsetWidth;
  let height = element.offsetHeight;
  // 由于getBoundingClientRect是基于 getClientRects的，mdn中说明到，小数级别的像素偏移是有可能的。这里做了一些容错。
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    // 返回element距离element.offsetParent的左边界偏移的像素值
    x: element.offsetLeft,
    // 同上
    y: element.offsetTop,
    width,
    height,
  };

}
```

1.  [getBoundingClientRect](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect)方法返回元素大小及其相对**视窗(viewport)** 的位置。

> 如果是标准盒子模型，元素的尺寸等于`width/height` + `padding` + `border-width`的总和。如果`box-sizing: border-box`，元素的的尺寸等于 `width/height`。

> 返回的结果是包含完整元素的最小矩形，并且拥有`left`, `top`, `right`, `bottom`, `x`, `y`, `width`, 和 `height`这几个以像素为单位的只读属性用于描述整个边框。除了`width` 和 `height` 以外的属性是相对于视图窗口的左上角来计算的。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b304c760fc347719ca76ceae13944b7~tplv-k3u1fbpfcp-zoom-1.image)

2.  `offsetWidth / offsetHeight` = `width/height` + `padding` + `border-width`
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42e69676718f4083aa9717cdb428fba0~tplv-k3u1fbpfcp-zoom-1.image)

由于`getBoundingClientRect`是基于 getClientRects的，mdn中说明到，小数级别的像素偏移是有可能的，所以在代码中做了一些容错做了一些容错。关于ClientRect是什么可以看这里 [DomRect](https://developer.mozilla.org/en-US/docs/Web/API/DOMRect)。

3.  `offsetLeft/offsetTop`

返回当前元素左上角相对于`offsetParent`左边/上边偏移的像素值

`offsetParent`元素只可能是下面这几种情况：

-   `<body>`

<!---->

-   `position`不是`static`的元素(position 默认值是 `static`)

<!---->

-   `<table>`, `<th>` 或`<td>`，但必须要`position: static`。

实际这个 `getLayoutRect`返回了 `popper` 的 `width/height`和 距离 `reference` 的x,y(一般情况下都是采用position:absolute | fixed)

> 有关更多各种offsetXXX的属性可以看张鑫旭大佬的这篇文章 [CSSOM视图模式(CSSOM View Module)相关整理 « 张鑫旭-鑫空间-鑫生活](https://www.zhangxinxu.com/wordpress/2011/09/cssom%e8%a7%86%e5%9b%be%e6%a8%a1%e5%bc%8fcssom-view-module%e7%9b%b8%e5%85%b3%e6%95%b4%e7%90%86%e4%b8%8e%e4%bb%8b%e7%bb%8d/) 里面还贴心的配备了各种demo。给大佬点赞！！！。

2.  ##### `reference`

```js
state.rects = {
   reference: getCompositeRect(
        reference,
        getOffsetParent(popper),
        state.options.strategy === 'fixed'
      ),
   // some code
        };
// 获取一个正确的offsetParent 针对 Element.offsetParent的特殊情况纠正
function getOffsetParent(element: Element) {
  const window = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);
  while (
    offsetParent &&
    isTableElement(offsetParent) &&
    getComputedStyle(offsetParent).position === 'static'
  ) {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (
    offsetParent &&
    (getNodeName(offsetParent) === 'html' ||
      (getNodeName(offsetParent) === 'body' &&
        getComputedStyle(offsetParent).position === 'static'))
  ) {
    return window;
  }
  return offsetParent || getContainingBlock(element) || window;
}

getTrueOffsetParent(element: Element): ?Element {
  if (
    !isHTMLElement(element) ||
    // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle(element).position === 'fixed'
  ) {
    return null;
  }
  return element.offsetParent;

}
```

`getOffsetParent` 函数返回值为 `offsetParent` | `window`。

```js
function getCompositeRect(
  elementOrVirtualElement: Element | VirtualElement,
  offsetParent: Element | Window,
  isFixed: boolean = false
): Rect {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const offsetParentIsScaled =
    isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  // 取到 DomRect
  const rect = getBoundingClientRect(
    elementOrVirtualElement,
    offsetParentIsScaled
  );
  // ------------------开始计算scroll和offsets
  let scroll = { scrollLeft: 0, scrollTop: 0 };
  let offsets = { x: 0, y: 0 };
  if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {
    if (
      getNodeName(offsetParent) !== 'body' ||
      // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)
    ) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  // ------------------计算结束-------------------
  return {
   // left + scrollLeft - offsetParent.clientLeft
    x: rect.left + scroll.scrollLeft - offsets.x,
    // top + scrollTop - offsetParent.clientTop
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height,
  };
}
```

emmmm,这里的x,y我也没看太懂为啥要减去 `offset.x|y`，暂时就当他为0吧。。。。看了半天实际上就是返回了`reference`的`width，height`以及`left+scrollLeft`和`top+scrollTop`

***

可以看出来的是，每次update时，会重新计算rects、modifiersData，重新执行modifier[fn]。

通过上面的代码，可以看出 不同的Modifier主要是影响了两个部分

1.  effect的执行，仅在setOptions时执行，只在generator时 执行了一次
1.  modifier[fn]的执行，仅在Update时执行。update的执行可由effect来控制。每次触发eventListener都会执行。

### Modifiers

#### Effect

```js
const defaultModifiers = [
  eventListeners,
  popperOffsets,
  computeStyles,
  applyStyles,
  offset,
  flip,
  preventOverflow,
  arrow,
  hide,
];
```

默认的Modifiers中，拥有effect函数的有，`eventListeners`、`applyStyles`、`arrow`。先来看一下这三个Modifier的effect函数分别做了什么。

1.  ##### eventListeners
在前面已经看过了，这里就不做分析。该方法主要是注册监听器和取消监听器。

2.  ##### applyStyles

```js
function effect({ state }) {
  const initialStyles = {
    // 初始化initial popper styles
    popper: {
      position: state.options.strategy, // 默认为 absolute
      left: '0',
      top: '0',
      margin: '0',
    },
    // 初始化 initial arrow
    arrow: {
      position: 'absolute',
    },
    // reference
    reference: {},
  };
  // 合并 popper style
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  // 合并 arrow style 设置position
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  // clearnUp Fn
  return () => {
    Object.keys(state.elements).forEach((name) => {
      // 取出element
      const element = state.elements[name];
      //  取出 attribute
      const attributes = state.attributes[name] || {};
      // styleProperties
      const styleProperties = Object.keys(
        state.styles.hasOwnProperty(name)
          ? state.styles[name]
          : initialStyles[name]
      );
      // Set all values to an empty string to unset them
      const style = styleProperties.reduce((style, property) => {
        style[property] = '';
        return style;
      }, {});
      // arrow is optional + virtual elements
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      // 移除apply的initalStyle
      Object.keys(attributes).forEach((attribute) => {
        element.removeAttribute(attribute);
      });
    });
  };
}
```

该方法针对 `popper`和`arrow`做了一些style样式的合并和删除操作

3.  ##### Arrow

```js
// Specifies the element to position as the arrow. This element must be a child of the popper element.
// A string represents a CSS selector queried within the context of the popper element.
// Popper will automatically pick up the following element (using the data-popper-arrow attribute) and position it:
// arrow type = Element | String
function effect({ state, options }) {
  let { element: arrowElement = '[data-popper-arrow]' } = options;
  // 若没有arrowElement return
  if (arrowElement == null) {
    return;
  }
  // CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  // arrow 设置
  state.elements.arrow = arrowElement;
}
```
通过这三个 `effect`，可以发现，`eventListeners`主要是设置`update`更新机制，applyStyles主要是 merge `refenerce`、`popper`、`arrow`的style。`Arrow`主要是设置小箭头的elements。

#### Modifier[fn]

除`eventListeners`这个Modifier 之外，其他的基本上都有fn方法，逐个攻破！

这里要注意的是，Modifier执行顺序是不可打乱的，在`setOptions`时，有这样一段代码,将默认的`modifiers`放置到了最前面。

```js
// defaultModifiers 是默认的Modifiers
const orderedModifiers = orderModifiers(
          mergeByName([...defaultModifiers, ...state.options.modifiers])
        );
```
1.  ##### popperOffsets

```js
function popperOffsets({ state, name }) {
  // offsets 是popper需要被正确放置在参考元素附近的实际位置，
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement,
  });
}
function computeOffsets({
  reference,
  element,
  placement,
}){
  // 获取 placement  'top' | 'bottom' | 'left' | 'right';
  const basePlacement = placement ? getBasePlacement(placement) : null;
  // 获取方位 'start' | 'end';
  const variation = placement ? getVariation(placement) : null;
  // 基准坐标 x 可以理解为 距离页面左边的宽度 + reference宽度 / 2 - (popper的宽度 / 2)
  const commonX = reference.x + reference.width / 2 - element.width / 2;
  // 基准坐标 y 可以理解为 距离页面上边的宽度 + reference高度 / 2 - (popper的高度 / 2)
  const commonY = reference.y + reference.height / 2 - element.height / 2;
  // 基本为 reference 中心点 向左上偏移 [element.width / 2,element.height / 2];
  let offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height,
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height,
      };
      break;
    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY,
      };
      break;
    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY,
      };
      break;
    default:
      offsets = {
        x: reference.x,
        y: reference.y,
      };
  }
  const mainAxis = basePlacement
    ? getMainAxisFromPlacement(basePlacement)
    : null;
  if (mainAxis != null) {
    const len = mainAxis === 'y' ? 'height' : 'width';
    switch (variation) {
      case start:
        offsets[mainAxis] =
          offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] =
          offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}
```

代码解释起来看上去不是很好理解，看图

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abb7f98694d8401e834b5e10322fddd4~tplv-k3u1fbpfcp-zoom-1.image)

`offsets` 先会根据`basePlacement`计算出 4种情况的定位 **基点。**

> 基点就是 popper element 左上角的那个点，这也是为什么offset看上去奇奇怪怪的。

假设popper 的 width 和 height 均为 0。 是不是就更容易理解了

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f121d8f6af6412588d18c09b0395689~tplv-k3u1fbpfcp-zoom-1.image)

然后根据 `mainAxis`和`variation`主轴(x | y)计算 `start | end` 的偏移量 。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f3f48da7e9e44a358d04670eaaa58d88~tplv-k3u1fbpfcp-zoom-1.image)

最终生成 `offsets:{x:number,y:number}`，基点坐标，将它存储进入 `modifiersData`中。字段名为 `popperOffsets`。


2.  ##### computeStyles

主要计算 `popper`、`arrow`的 style 样式，开启GPU加速(使用transform)，一些误差的磨平。

```js
function computeStyles({ state, options }) {
  const {
    // gpu加速 默认开启
    gpuAcceleration = true,
    // 自适应 默认开启
    adaptive = true,
    // defaults to use builtin `roundOffsetsByDPR`
    roundOffsets = true,
  } = options;
  
  const commonStyles = {
    // top、bottom、start、end
    placement: getBasePlacement(state.placement),
    // start、end
    variation: getVariation(state.placement),
    // element
    popper: state.elements.popper,
    // update中生成的 rect
    popperRect: state.rects.popper,
    // gpu加速
    gpuAcceleration,
    isFixed: state.options.strategy === 'fixed',
  };
  // 在popperOffsets中生成的
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = {
      ...state.styles.popper,
      ...mapToStyles({
        ...commonStyles,
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets,
      }),
    };
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = {
      ...state.styles.arrow,
      ...mapToStyles({
        ...commonStyles,
        offsets: state.modifiersData.arrow,
        position: 'absolute',
        adaptive: false,
        roundOffsets,
      }),
    };
  }
  state.attributes.popper = {
    ...state.attributes.popper,
    'data-popper-placement': state.placement,
  };
}

function mapToStyles({popper,popperRect,placement,variation,offsets,position,gpuAcceleration,adaptive,roundOffsets,isFixed,}) 
{
  // offsets 来自于 popperOffsets 中生成
  let { x = 0, y = 0 } = offsets;
  const hasX = offsets.hasOwnProperty('x');
  const hasY = offsets.hasOwnProperty('y');
  let sideX: string = left;
  let sideY: string = top;
  const win: Window = window;
  // 自适应处理逻辑 存在一些 style的变换
  if (adaptive) {
    // ... some code 
  }
  // 经过自适应处理过后的style
  const commonStyles = {
    position,
    ...(adaptive && unsetSides),
  };
    // 默认为 true 自定义取消误差函数
  ({ x, y } =
    typeof roundOffsets === 'function'
      ? roundOffsets({ x, y })
      : { x, y });
  // 取消误差 因为不同分辨率下可能会存在一些误差而导致渲染错位，通常会有<1px的误差
  ({ x, y } =
    roundOffsets === true
      ? roundOffsetsByDPR({ x, y })
      : { x, y });
  // 如果开启gpu加速的话 使用transform
  if (gpuAcceleration) {
    return {
      ...commonStyles,
      [sideY]: hasY ? '0' : '',
      [sideX]: hasX ? '0' : '',
      // Layer acceleration can disable subpixel rendering which causes slightly
      // blurry text on low PPI displays, so we want to use 2D transforms
      // instead
      transform:
        (win.devicePixelRatio || 1) <= 1
          ? `translate(${x}px, ${y}px)`
          : `translate3d(${x}px, ${y}px, 0)`,
    };
  }
  // 不开启gpu加速返回得结果
  return {
    ...commonStyles,
    [sideY]: hasY ? `${y}px` : '',
    [sideX]: hasX ? `${x}px` : '',
    transform: '',
  };
}
```

3.  ##### applyStyles

将 `popper`、`arrow`、`reference`等原有的 style 和 attribute 与 `computeSytles` 中计算出的 style 样式进行合并。

```js
function applyStyles({ state }: ModifierArguments<{||}>) {
  // 取出 reference、 popper、arrow 设置 style、attributes等
  Object.keys(state.elements).forEach((name) => {
    const style = state.styles[name] || {};
    const attributes = state.attributes[name] || {};
    const element = state.elements[name];
    // arrow is optional + virtual elements
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]
    Object.assign(element.style, style);
    // 针对 attribute 特殊处理
    Object.keys(attributes).forEach((name) => {
      const value = attributes[name];
      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
     }
    });
  });
}
```

4.  ##### Offsets

**注：这里的offsets指的是用户自定义的一些偏移量，而不是计算得出的 `popperOffsets`。**

```js
function offset({ state, options, name }: ModifierArguments<Options>) {
  // options传入的参数 [0,0] 可以理解为用户自定义额外的偏移量
  const { offset = [0, 0] } = options;
  // 由于接下来的溢出检测，自动切换位置可能会需要其他方向的偏移量，所以这边一次性所有方位全部生成，而避免了每次计算，每次生成。
  const data = placements.reduce((acc, placement) => {
    // 根据placements生成 每个方位的偏移量
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  const { x, y } = data[state.placement];
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  // 更新 modifiersData popperOffsets
  state.modifiersData[name] = data;
}
```
5.  ##### flip

```js
function flip({ state, options, name }) {
    // flip skip    
    if (state.modifiersData[name]._skip) {
        return;
    }
    // 
    const {
        mainAxis: checkMainAxis = true,
        altAxis: checkAltAxis = true,
        // 默认可供尝试的placements
        fallbackPlacements: specifiedFallbackPlacements,
        // 会对boundary边界进行虚拟填充
        padding,
        // popper
        boundary,
        // reference
        rootBoundary,
        // arrow
        altBoundary,
        // top-start => top-end 尝试翻转变化
        flipVariations = true,
        allowedAutoPlacements,
    } = options;
    // custom placement??
    const preferredPlacement = state.options.placement;
    // 'top-start' => 'top'
    const basePlacement = getBasePlacement(preferredPlacement);
    const isBasePlacement = basePlacement === preferredPlacement;
    // 获取 当发生溢出时，可供尝试的Placements，默认情况下应该为 specifiedFallbackPlacements，
    //若没有 specifiedFallbackPlacements 则根据placement来生成fallbackPlacements
    const fallbackPlacements =
        specifiedFallbackPlacements ||
        (isBasePlacement || !flipVariations ?
            [getOppositePlacement(preferredPlacement)] :
            getExpandedFallbackPlacements(preferredPlacement));
    // 生成的placements
    const placements = [preferredPlacement, ...fallbackPlacements].reduce(
        (acc, placement) => {
            return acc.concat(
                // 当placement为 'auto'时，自动生成一个可能能用的placement
                getBasePlacement(placement) === auto ?
                computeAutoPlacement(state, {
                    placement,
                    boundary,
                    rootBoundary,
                    padding,
                    flipVariations,
                    allowedAutoPlacements,
                }) :
                placement
            );
        }, []
    );
}
```

[fallbackPlacements有关的一些说明](https://popper.js.org/docs/v2/modifiers/flip/#fallbackplacements)，假设我们原有的`placement`设置为`button`，当没有足够的空间来容纳它时，会使用`fallbackPlacements`中的参数来进行尝试。`pacements` 有下面三种情况：
-   `specifiedFallbackPlacements`参数，则直接使用参数，
-   是`basePlacement(top | left | right | bottom)`，则会取反，例如 原来是`top`，取反会是 `bottom`
-   `是 top-start`，会先尝试 `top-end`、`bottom-start`、`bottom-end`这三种情况。
-   是 `auto`，则执行 `computeAutoPlacement`进行计算。

```js
    const referenceRect = state.rects.reference;
    const popperRect = state.rects.popper;
    const checksMap = new Map();
    let makeFallbackChecks = true;
    let firstFittingPlacement = placements[0];
    // 开始生成checksMap
    for (let i = 0; i < placements.length; i++) {
        const placement = placements[i];
        const basePlacement = getBasePlacement(placement);
        const isStartVariation = getVariation(placement) === start;
        // 方向 x | y
        const isVertical = [top, bottom].indexOf(basePlacement) >= 0;
        
        // 检测溢出 
        const overflow = detectOverflow(state, {
            placement,
            boundary,
            rootBoundary,
            altBoundary,
            padding,
        });
```
这里的是 经过 `detectOverflow`函数，生成了 `overflow`，利用 `overflow` 来判断可用的` placement`。看一下 `detectOverflow`是如何检测溢出的。

```js
function detectOverflow(state,option){
  const {
    placement = state.placement,
    boundary = clippingParents,
    rootBoundary = viewport,
    // flip调用时，没有传入elementContext，为默认值
    elementContext = popper,
    // true => reference || false => popper
    altBoundary = false,
    // padding 检测距离，用户传入参数
    padding = 0,
  } = options;
  // 根据padding和 basePlacements生成 
  // paddingObject，默认是{top:0,left:0,right:0,bottom:0}
  // 假设padding = 10,则为 {top:10,left:10,right:10,bottom:10}
  const paddingObject = mergePaddingObject(
    typeof padding !== 'number'
      ? padding
      : expandToHashMap(padding, basePlacements)
  );
  // altContext 在flip调用时 默认为 reference
  const altContext = elementContext === popper ? reference : popper;
  const popperRect = state.rects.popper;
  // element 默认为 popper
  const element = state.elements[altBoundary ? altContext : elementContext];
  // 生成一个clippingclient {width,height,x,y} // 这个clippingclientRect默认情况下指的是父节点的滚动区域大小或者是 viewport大小
  // 原有的注释：Gets the maximum area that the element is visible in due to any number of clipping parents
  const clippingClientRect = getClippingRect(
    isElement(element)
      ? element
      : element.contextElement || getDocumentElement(state.elements.popper),
    boundary, // clippingParents
    rootBoundary // viewport
  );
// 浏览器中的 真正大小, getBoundingClientRect函数重写了element. getBoundingClientRect，其中对页面的缩放及一些element.getBoundingClientRect错误情况做了容错处理。这里可以直接理解为element.getBoundingClientRect的返回值
  const referenceClientRect = getBoundingClientRect(state.elements.reference);
  // computeOffsets 在popperOffsets中用到过，这里就不做说明了，会生成一个基点坐标
  const popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement,
  });
  根据得到的基点坐标，生成新的 popperClientRect
  const popperClientRect = rectToClientRect({
    ...popperRect,
    ...popperOffsets,
  });
  // elementClientRect默认值为 popperClientRect
  const elementClientRect =
    elementContext === popper ? popperClientRect : referenceClientRect;
  // 四个方向检测是否有溢出，如果有溢出的话，例如：top:10,
  const overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom:
      elementClientRect.bottom -
      clippingClientRect.bottom +
      paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right:
      elementClientRect.right - clippingClientRect.right + paddingObject.right,
  };
   // 获取在offsets生成的offsetData
  const offsetData = state.modifiersData.offset;
  // Offsets can be applied only to the popper element
  if (elementContext === popper && offsetData) {
    const offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach((key) => {
      const multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      const axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }
  return overflowOffsets;
}
```
代码有点复杂，来分析一下`detectOverflow`函数做了什么
1. 根据 `padding` 生成 `paddingObject`，
2. 判断是检测 `popper`还是 `reference`，生成`altContext`
3. 根据`altContext`，生成 `clippingClientRect`,该变量默认情况下是父节点滚动区域的大小或者 viewport的可视区域大小,为`altContext`可见的最大区域
4. `elementClientRect` 为 **此时此刻**，`reference.getBoundingClientRect()`或者 `popperClientRect`
5. 生成 `overflowOffsets`，举例：`top`为 `clippingClientRect.top` - `elementClientRect.top` + `paddingObject.top`，正常情况下若可用为负数


最终，我们返回了`overflowOffsets`，它包含了4个方位是否有溢出的情况。目前，我们仅分析默认情况，传参情况暂不考虑。

```js
        // 分区
        // right:top-start、bottom-start
        // left:top-end、bottom-end
        // bottom:left-start、right-start
        // top:left-end、right-end
        let mainVariationSide: any = isVertical ?
            (isStartVariation ?
              right :
              left ):
            (isStartVariation ?
              bottom :
              top);
        const len = isVertical ? 'width' : 'height';
        // 若 reference width | height > popper 取反向，没太想通为什么要取反向
        // 刚刚得到的right会变成 left
        if (referenceRect[len] > popperRect[len]) {
            mainVariationSide = getOppositePlacement(mainVariationSide);
        }
        
        const altVariationSide: any = getOppositePlacement(mainVariationSide);
        const checks = [];
        // 这里需要注意正数为不可用，负数|| 0 为可用,还有空间
        if (checkMainAxis) {
            checks.push(overflow[basePlacement] <= 0);
        }
        if (checkAltAxis) {
            checks.push(
                overflow[mainVariationSide] <= 0,
                overflow[altVariationSide] <= 0
            );
        }
        // 若有一个可用的位置
        if (checks.every((check) => check)) {
            firstFittingPlacement = placement;
            makeFallbackChecks = false;
            break;
        }
        checksMap.set(placement, checks);
    }
    // 如果没有可用的placement
    if (makeFallbackChecks) {
        // `2` may be desired in some cases – research later
        const numberOfChecks = flipVariations ? 3 : 1;
        for (let i = numberOfChecks; i > 0; i--) {
            const fittingPlacement = placements.find((placement) => {
                const checks = checksMap.get(placement);
                if (checks) {
                    return checks.slice(0, i).every((check) => check);
                }
            });
            if (fittingPlacement) {
                firstFittingPlacement = fittingPlacement;
                break;
            }
        }
    }
    // 若placement与预设的不同，则_skip为true。
    if (state.placement !== firstFittingPlacement) {
        state.modifiersData[name]._skip = true;
        state.placement = firstFittingPlacement;
        state.reset = true;
    }
```

Flip 是这样，整体执行流程大致为，设置一些`placements`，检测`popper`四个方向，根据`placements`和`overflowOffsets`来推算哪个placements可以使用，如果某一个可以使用，结束退出函数。

6.  ##### preventOverflow
这部分实在是懒得写了，QAQ。简单介绍一下他的作用，计算出reference在什么情况下应该算溢出，然后记录下这个值，以便后面使用

7.  ##### Arrow
```js
function arrow({ state, name, options }: ModifierArguments<Options>) {
  // 
  const arrowElement = state.elements.arrow;
  // 
  const popperOffsets = state.modifiersData.popperOffsets;
  // top/bottom/left/right
  const basePlacement = getBasePlacement(state.placement);
  // top/bottom => x left/right => y
  const axis = getMainAxisFromPlacement(basePlacement);
  const isVertical = [left, right].indexOf(basePlacement) >= 0;
  const len = isVertical ? 'height' : 'width';
  // 若无arrow元素或者 无popper的offset
  if (!arrowElement || !popperOffsets) {
    return;
  }
  // 边距
  const paddingObject = toPaddingObject(options.padding, state);
  const arrowRect = getLayoutRect(arrowElement);
  const minProp = axis === 'y' ? top : left;
  const maxProp = axis === 'y' ? bottom : right;
  const endDiff =
    state.rects.reference[len] +
    state.rects.reference[axis] -
    popperOffsets[axis] -
    state.rects.popper[len];
  const startDiff = popperOffsets[axis] - state.rects.reference[axis];
  const arrowOffsetParent = getOffsetParent(arrowElement);
  const clientSize = arrowOffsetParent
    ? axis === 'y'
      ? arrowOffsetParent.clientHeight || 0
      : arrowOffsetParent.clientWidth || 0
    : 0;
  const centerToReference = endDiff / 2 - startDiff / 2;
  // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds
  const min = paddingObject[minProp];
  const max = clientSize - arrowRect[len] - paddingObject[maxProp];
  const center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  const offset = within(min, center, max);
  // Prevents breaking syntax highlighting...
  const axisProp: string = axis;
  state.modifiersData[name] = {
    [axisProp]: offset,
    centerOffset: offset - center,
  };
```
计算出arrow的位置。
8.  ##### hide

```js
function hide({ state, name }: ModifierArguments<{||}>) {
  const referenceRect = state.rects.reference;
  const popperRect = state.rects.popper;
  const preventedOffsets = state.modifiersData.preventOverflow;
  // referenceOverflow是否溢出
  const referenceOverflow = detectOverflow(state, {
    elementContext: 'reference',
  });
  // popper是否溢出
  const popperAltOverflow = detectOverflow(state, {
    altBoundary: true,
  });
  const referenceClippingOffsets = getSideOffsets(
    referenceOverflow,
    referenceRect
  );
  const popperEscapeOffsets = getSideOffsets(
    popperAltOverflow,
    popperRect,
    preventedOffsets
  );
  const isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  const hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped,
  };
  state.attributes.popper = {
    ...state.attributes.popper,
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped,
  };
}
```

分别判断了，`reference` 和`popper`是否溢出，如果溢出的话，则hide。
### End 

第二弹到此结束了，有关popper.js仅分为2篇，这是第2篇。该文章仅是我个人的一些理解，难免有一些不对的地方，欢迎大家批评指正！！！ 如果可以的话，占用你一些时间，帮我点个赞吧👍🏻👍🏻👍🏻👍🏻👍🏻👍🏻~
